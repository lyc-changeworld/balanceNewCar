###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        16/Aug/2016  15:26:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\app\init.c
#    Command line =  
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\app\init.c -D LPLD_K60 -D
#        USE_K60D10 -lCN
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\FLASH\List\ -lB
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\FLASH\List\ -o
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\FLASH\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "F:\Program
#        Files\IAR_FOR_ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\app\ -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\CPU\ -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\common\
#        -I E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\LPLD\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\LPLD\HW\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\FatFs\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\FatFs\option\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\USB\common\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\USB\driver\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\USB\descriptor\
#        -I
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\..\..\..\lib\USB\class\
#        -Ol -I "F:\Program Files\IAR_FOR_ARM\arm\CMSIS\Include\" -D
#        ARM_MATH_CM4
#    List file    =  
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\FLASH\List\init.lst
#    Object file  =  
#        E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\iar\FLASH\Obj\init.o
#
###############################################################################

E:\LPLD_OSKinetis_V3.1\project\balanceNewCar\app\init.c
      1          #include "init.h"
      2          #include "speed.h"
      3          
      4          //#define SPEED_TIME 50  //50MS     5ms更新一个数据，取历史45ms中的9个数据平均值来计算速度量
      5          #define DIRECT_TIME  10 //10MS
      6          
      7          //结构体声明

   \                                 In section .bss, align 4
      8          UART_InitTypeDef uart3_init_struct;                       //串口发送
   \                     uart3_init_struct:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
      9          ADC_InitTypeDef adc0_init_struct;
   \                     adc0_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     10          ADC_InitTypeDef adc1_init_struct;
   \                     adc1_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     11          ADC_InitTypeDef adc2_init_struct;                        //采样
   \                     adc2_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     12          PIT_InitTypeDef pit0_init_struct;                        //总功能定时器
   \                     pit0_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     13          PIT_InitTypeDef pit1_runTime;                   //测速模块定时器
   \                     pit1_runTime:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     14          GPIO_InitTypeDef   INPUT1_Init;
   \                     INPUT1_Init:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     15          GPIO_InitTypeDef   INPUT2_Init;
   \                     INPUT2_Init:
   \   00000000                      DS8 20
     16          

   \                                 In section .text, align 2, keep-with-next
     17          void adc_init(void)//初始化ADC及其通道
     18          {
   \                     adc_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     19            adc0_init_struct.ADC_Adcx = ADC0;                       //E24、E25
   \   00000002   0x....             LDR.N    R0,??DataTable3  ;; 0x4003b000
   \   00000004   0x....             LDR.N    R1,??DataTable3_1
   \   00000006   0x6008             STR      R0,[R1, #+0]
     20            adc0_init_struct.ADC_DiffMode = ADC_SE;                 //单端采集
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable3_1
   \   0000000C   0x7108             STRB     R0,[R1, #+4]
     21            adc0_init_struct.ADC_BitMode = SE_8BIT;                 //单端8位精度
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable3_1
   \   00000012   0x7148             STRB     R0,[R1, #+5]
     22            adc0_init_struct.ADC_LongSampleTimeSel=LSAMTIME_12EX;   //长采样时间
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable3_1
   \   00000018   0x71C8             STRB     R0,[R1, #+7]
     23            //adc0_init_struct.ADC_HwAvgSel = HW_4AVG;              //4次硬件平均
     24            adc0_init_struct.ADC_CalEnable = TRUE;                  //使能初始化校验
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable3_1
   \   0000001E   0x72C8             STRB     R0,[R1, #+11]
     25            
     26            adc1_init_struct.ADC_Adcx = ADC0;                       //D5、D6
   \   00000020   0x....             LDR.N    R0,??DataTable3  ;; 0x4003b000
   \   00000022   0x....             LDR.N    R1,??DataTable3_2
   \   00000024   0x6008             STR      R0,[R1, #+0]
     27            adc1_init_struct.ADC_DiffMode = ADC_SE;                 //单端采集
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable3_2
   \   0000002A   0x7108             STRB     R0,[R1, #+4]
     28            adc1_init_struct.ADC_BitMode = SE_8BIT;                 //单端8位精度
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable3_2
   \   00000030   0x7148             STRB     R0,[R1, #+5]
     29            adc1_init_struct.ADC_MuxSel=MUX_ADXXB;                  //单端B通道输入
   \   00000032   0x2010             MOVS     R0,#+16
   \   00000034   0x....             LDR.N    R1,??DataTable3_2
   \   00000036   0x7288             STRB     R0,[R1, #+10]
     30            adc1_init_struct.ADC_LongSampleTimeSel=LSAMTIME_12EX;   //长采样时间
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x....             LDR.N    R1,??DataTable3_2
   \   0000003C   0x71C8             STRB     R0,[R1, #+7]
     31            //adc1_init_struct.ADC_HwAvgSel = HW_4AVG;              //4次硬件平均
     32            adc1_init_struct.ADC_CalEnable = TRUE;                  //使能初始化校验
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x....             LDR.N    R1,??DataTable3_2
   \   00000042   0x72C8             STRB     R0,[R1, #+11]
     33            
     34            adc2_init_struct.ADC_Adcx = ADC1;                       //E2、E3、A17
   \   00000044   0x....             LDR.N    R0,??DataTable3_3  ;; 0x400bb000
   \   00000046   0x....             LDR.N    R1,??DataTable3_4
   \   00000048   0x6008             STR      R0,[R1, #+0]
     35            adc2_init_struct.ADC_DiffMode = ADC_SE;                 //单端采集
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x....             LDR.N    R1,??DataTable3_4
   \   0000004E   0x7108             STRB     R0,[R1, #+4]
     36            adc2_init_struct.ADC_BitMode = SE_8BIT;                 //单端8位精度
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x....             LDR.N    R1,??DataTable3_4
   \   00000054   0x7148             STRB     R0,[R1, #+5]
     37            adc2_init_struct.ADC_MuxSel=MUX_ADXXA;                  //单端A通道输入
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x....             LDR.N    R1,??DataTable3_4
   \   0000005A   0x7288             STRB     R0,[R1, #+10]
     38            adc2_init_struct.ADC_LongSampleTimeSel=LSAMTIME_12EX;   //长采样时间
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x....             LDR.N    R1,??DataTable3_4
   \   00000060   0x71C8             STRB     R0,[R1, #+7]
     39            //adc2_init_struct.ADC_HwAvgSel = HW_4AVG;              //4次硬件平均
     40            adc2_init_struct.ADC_CalEnable = TRUE;                  //使能初始化校验
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x....             LDR.N    R1,??DataTable3_4
   \   00000066   0x72C8             STRB     R0,[R1, #+11]
     41            
     42            LPLD_ADC_Init(adc0_init_struct);
   \   00000068   0x....             LDR.N    R1,??DataTable3_1
   \   0000006A   0xB084             SUB      SP,SP,#+16
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x2214             MOVS     R2,#+20
   \   00000070   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000074   0xBC0F             POP      {R0-R3}
   \   00000076   0x.... 0x....      BL       LPLD_ADC_Init
     43            LPLD_ADC_Init(adc1_init_struct);
   \   0000007A   0x....             LDR.N    R1,??DataTable3_2
   \   0000007C   0xB084             SUB      SP,SP,#+16
   \   0000007E   0x4668             MOV      R0,SP
   \   00000080   0x2214             MOVS     R2,#+20
   \   00000082   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000086   0xBC0F             POP      {R0-R3}
   \   00000088   0x.... 0x....      BL       LPLD_ADC_Init
     44            LPLD_ADC_Init(adc2_init_struct);                        //初始化ADC
   \   0000008C   0x....             LDR.N    R1,??DataTable3_4
   \   0000008E   0xB084             SUB      SP,SP,#+16
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x2214             MOVS     R2,#+20
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000098   0xBC0F             POP      {R0-R3}
   \   0000009A   0x.... 0x....      BL       LPLD_ADC_Init
     45            //陀螺仪采样口
     46            LPLD_ADC_Chn_Enable(ADC1, AD6);                         //PTE2 Y轴的陀螺仪接口（前进方向上的）
   \   0000009E   0x2106             MOVS     R1,#+6
   \   000000A0   0x....             LDR.N    R0,??DataTable3_3  ;; 0x400bb000
   \   000000A2   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     47            LPLD_ADC_Chn_Enable(ADC1, AD7);                         //PTE3 X轴的陀螺仪接口（转弯平面上的，备用）
   \   000000A6   0x2107             MOVS     R1,#+7
   \   000000A8   0x....             LDR.N    R0,??DataTable3_3  ;; 0x400bb000
   \   000000AA   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     48            /********电磁采样口，顺序为板子上的1到5口**********/
     49            LPLD_ADC_Chn_Enable(ADC0, AD7);                         //D6
   \   000000AE   0x2107             MOVS     R1,#+7
   \   000000B0   0x....             LDR.N    R0,??DataTable3  ;; 0x4003b000
   \   000000B2   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     50            LPLD_ADC_Chn_Enable(ADC0, AD6);                         //D5
   \   000000B6   0x2106             MOVS     R1,#+6
   \   000000B8   0x....             LDR.N    R0,??DataTable3  ;; 0x4003b000
   \   000000BA   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     51            LPLD_ADC_Chn_Enable(ADC1, AD17);                        //A17
   \   000000BE   0x2111             MOVS     R1,#+17
   \   000000C0   0x....             LDR.N    R0,??DataTable3_3  ;; 0x400bb000
   \   000000C2   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     52            LPLD_ADC_Chn_Enable(ADC0, AD18);                       //E25
   \   000000C6   0x2112             MOVS     R1,#+18
   \   000000C8   0x....             LDR.N    R0,??DataTable3  ;; 0x4003b000
   \   000000CA   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     53            LPLD_ADC_Chn_Enable(ADC0, AD17);                       //E24
   \   000000CE   0x2111             MOVS     R1,#+17
   \   000000D0   0x....             LDR.N    R0,??DataTable3  ;; 0x4003b000
   \   000000D2   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     54          }
   \   000000D6   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     55          void uart_init(void)//初始化UART3模块
     56          {
   \                     uart_init: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
     57            uart3_init_struct.UART_Uartx = UART3;                  //使用UART3
   \   00000002   0x....             LDR.N    R0,??DataTable3_5  ;; 0x4006d000
   \   00000004   0x....             LDR.N    R1,??DataTable3_6
   \   00000006   0x6008             STR      R0,[R1, #+0]
     58            uart3_init_struct.UART_BaudRate = 115200;              //设置波特率9600
   \   00000008   0xF45F 0x30E1      MOVS     R0,#+115200
   \   0000000C   0x....             LDR.N    R1,??DataTable3_6
   \   0000000E   0x6048             STR      R0,[R1, #+4]
     59            uart3_init_struct.UART_RxPin = PTE5;                   //接收引脚为PTE5
   \   00000010   0x2081             MOVS     R0,#+129
   \   00000012   0x....             LDR.N    R1,??DataTable3_6
   \   00000014   0x7248             STRB     R0,[R1, #+9]
     60            uart3_init_struct.UART_TxPin = PTE4;                   //发送引脚为PTE4
   \   00000016   0x2080             MOVS     R0,#+128
   \   00000018   0x....             LDR.N    R1,??DataTable3_6
   \   0000001A   0x7208             STRB     R0,[R1, #+8]
     61            LPLD_UART_Init(uart3_init_struct);                     //初始化UART
   \   0000001C   0x....             LDR.N    R1,??DataTable3_6
   \   0000001E   0xB084             SUB      SP,SP,#+16
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x221C             MOVS     R2,#+28
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000028   0xBC0F             POP      {R0-R3}
   \   0000002A   0x.... 0x....      BL       LPLD_UART_Init
     62          }
   \   0000002E   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
     63          void pit_init(void)
     64          {
   \                     pit_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     65            //配置PIT0参数   测量角度模块(陀螺仪积分测角及加速度计定期补偿)
     66            pit0_init_struct.PIT_Pitx = PIT0;                     //配置PIT0参数
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable3_7
   \   00000006   0x7008             STRB     R0,[R1, #+0]
     67            pit0_init_struct.PIT_PeriodMs = 5;                    //定时周期5ms
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x....             LDR.N    R1,??DataTable3_7
   \   0000000C   0x6088             STR      R0,[R1, #+8]
     68            pit0_init_struct.PIT_Isr = pit0_isr;                  //设置中断函数
   \   0000000E   0x....             LDR.N    R0,??DataTable3_8
   \   00000010   0x....             LDR.N    R1,??DataTable3_7
   \   00000012   0x6108             STR      R0,[R1, #+16]
     69            LPLD_PIT_Init(pit0_init_struct);                      //初始化PIT0
   \   00000014   0x....             LDR.N    R1,??DataTable3_7
   \   00000016   0xB084             SUB      SP,SP,#+16
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x2214             MOVS     R2,#+20
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000020   0xBC0F             POP      {R0-R3}
   \   00000022   0x.... 0x....      BL       LPLD_PIT_Init
     70            LPLD_PIT_EnableIrq(pit0_init_struct);
   \   00000026   0x....             LDR.N    R1,??DataTable3_7
   \   00000028   0xB084             SUB      SP,SP,#+16
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x2214             MOVS     R2,#+20
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000032   0xBC0F             POP      {R0-R3}
   \   00000034   0x.... 0x....      BL       LPLD_PIT_EnableIrq
     71            
     72          //  pit1_runTime.PIT_Pitx = PIT1;                //配置PIT1参数
     73          //  pit1_runTime.PIT_PeriodS = 20;                 //定时周期5ms
     74          //  pit1_runTime.PIT_Isr = RunTime_isr;            //设置中断函数
     75          //  LPLD_PIT_Init(pit1_runTime);                   //初始化PIT0
     76          //  LPLD_PIT_EnableIrq(pit1_runTime);
     77          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
     78          
     79          
     80          /**
     81          * DMA测速模块
     82          */

   \                                 In section .text, align 2, keep-with-next
     83          void GPIO_DMA_Init(void)
     84          {
   \                     GPIO_DMA_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     85            INPUT1_Init.GPIO_PTx=PTB;
   \   00000002   0x....             LDR.N    R0,??DataTable3_9  ;; 0x400ff040
   \   00000004   0x....             LDR.N    R1,??DataTable3_10
   \   00000006   0x6008             STR      R0,[R1, #+0]
     86            INPUT1_Init.GPIO_Pins=GPIO_Pin0;/*左轮测速*/
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR.N    R1,??DataTable3_10
   \   0000000C   0x6048             STR      R0,[R1, #+4]
     87            INPUT1_Init.GPIO_Dir=DIR_INPUT;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable3_10
   \   00000012   0x7308             STRB     R0,[R1, #+12]
     88            INPUT1_Init.GPIO_PinControl=INPUT_PULL_DOWN|IRQC_DMARI;
   \   00000014   0x....             LDR.N    R0,??DataTable3_11  ;; 0x10002
   \   00000016   0x....             LDR.N    R1,??DataTable3_10
   \   00000018   0x6088             STR      R0,[R1, #+8]
     89            LPLD_GPIO_Init(INPUT1_Init);
   \   0000001A   0x....             LDR.N    R1,??DataTable3_10
   \   0000001C   0xB084             SUB      SP,SP,#+16
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x2214             MOVS     R2,#+20
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000026   0xBC0F             POP      {R0-R3}
   \   00000028   0x.... 0x....      BL       LPLD_GPIO_Init
     90            
     91            INPUT2_Init.GPIO_PTx=PTC ;
   \   0000002C   0x....             LDR.N    R0,??DataTable3_12  ;; 0x400ff080
   \   0000002E   0x....             LDR.N    R1,??DataTable3_13
   \   00000030   0x6008             STR      R0,[R1, #+0]
     92            INPUT2_Init.GPIO_Pins=GPIO_Pin8;/*右轮测速*/
   \   00000032   0xF44F 0x7080      MOV      R0,#+256
   \   00000036   0x....             LDR.N    R1,??DataTable3_13
   \   00000038   0x6048             STR      R0,[R1, #+4]
     93            INPUT2_Init.GPIO_Dir=DIR_INPUT;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable3_13
   \   0000003E   0x7308             STRB     R0,[R1, #+12]
     94            INPUT2_Init.GPIO_PinControl=INPUT_PULL_DOWN|IRQC_DMARI;
   \   00000040   0x....             LDR.N    R0,??DataTable3_11  ;; 0x10002
   \   00000042   0x....             LDR.N    R1,??DataTable3_13
   \   00000044   0x6088             STR      R0,[R1, #+8]
     95            LPLD_GPIO_Init(INPUT2_Init);
   \   00000046   0x....             LDR.N    R1,??DataTable3_13
   \   00000048   0xB084             SUB      SP,SP,#+16
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x2214             MOVS     R2,#+20
   \   0000004E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000052   0xBC0F             POP      {R0-R3}
   \   00000054   0x.... 0x....      BL       LPLD_GPIO_Init
     96          }
   \   00000058   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     adc0_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     adc1_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x400BB000         DC32     0x400bb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     adc2_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     uart3_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     pit0_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     pit0_isr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     INPUT1_Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     INPUT2_Init
     97          //void RunTime_isr(void)
     98          //{
     99          //  runTime = 1;
    100          //}
    101          /*void DMA_PIT_isr(void)
    102          {
    103          ch0_pulseacc = DMA_MAX_NUM - DMA0->TCD[DMA_CH1].CITER_ELINKNO;     //获得最终的脉冲累加值
    104          ch1_pulseacc = DMA_MAX_NUM - DMA0->TCD[DMA_CH2].CITER_ELINKNO;
    105          if(ch0_over_cnt !=0)
    106          {
    107          ch0_pulseacc = ch0_pulseacc + DMA_MAX_NUM*ch0_over_cnt;
    108          ch0_over_cnt = 0;             //清零溢出计数
    109            }
    110          if(ch1_over_cnt !=0)
    111          {
    112          ch1_pulseacc = ch1_pulseacc + DMA_MAX_NUM*ch1_over_cnt;
    113          ch1_over_cnt = 0;
    114            }
    115          //计划5ms测速一次，10次累计后滤波处理
    116          if(PTB9_I) {Speed_LQ[c_s]=(float)ch0_pulseacc;}//左轮方向校准,右轮正转时编码器顺时针转，为高
    117            else  {Speed_LQ[c_s]=-(float)ch0_pulseacc;}
    118          if(PTC16_I){Speed_RQ[c_s]=-(float)ch1_pulseacc;}//右轮方向校准，左轮正转时编码器逆时针转，为低
    119            else  {Speed_RQ[c_s]=(float)ch1_pulseacc;}
    120          //Speed_Q[c_s]=(Speed_LQ[c_s]+Speed_RQ[c_s])/2;//平均速度存储
    121          
    122          //50ms对采到的速度值滤波处理
    123          if(c_s==10)
    124          {
    125          c_s=0;
    126          GetMotorPulse();//测量当前的速度量
    127          speed_control();//速度电机量计算
    128            }
    129          c_s++;//5ms累加一次
    130          
    131          //初始化DMA模块
    132          LPLD_DMA_Init(DMA_Struct1); //初始化DMA模块
    133          LPLD_DMA_Init(DMA_Struct2);  
    134          LPLD_DMA_EnableReq(DMA_CH1); //开启通道请求
    135          LPLD_DMA_EnableReq(DMA_CH2);
    136          
    137          //  get_ad();//电感采样
    138          //cal_offset();//获取偏差
    139          oled_flag++;//oled显示标志
    140          direct_flag++;
    141          if(direct_flag==2)//10ms
    142          {
    143          direct_flag=0;
    144          DirectionSpeedControl();//差速电机量计算
    145            }
    146          if(oled_flag==20)//100ms刷新一次屏幕
    147          {
    148          oled_flag=0;
    149          show_info();
    150            }
    151          
    152          }*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   GPIO_DMA_Init
         8   -> LPLD_GPIO_Init
        24   -> __aeabi_memcpy4
      24   adc_init
         8   -> LPLD_ADC_Chn_Enable
         8   -> LPLD_ADC_Init
        24   -> __aeabi_memcpy4
      24   pit_init
         8   -> LPLD_PIT_EnableIrq
         8   -> LPLD_PIT_Init
        24   -> __aeabi_memcpy4
      32   uart_init
        16   -> LPLD_UART_Init
        32   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      90  GPIO_DMA_Init
      20  INPUT1_Init
      20  INPUT2_Init
      20  adc0_init_struct
      20  adc1_init_struct
      20  adc2_init_struct
     216  adc_init
      20  pit0_init_struct
      20  pit1_runTime
      58  pit_init
      28  uart3_init_struct
      48  uart_init

 
 168 bytes in section .bss
 468 bytes in section .text
 
 468 bytes of CODE memory
 168 bytes of DATA memory

Errors: none
Warnings: none
